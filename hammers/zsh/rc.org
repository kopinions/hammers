#+TITLE:  zsh 配置
#+AUTHOR: 孙建康（rising.lambda）
#+EMAIL:  rising.lambda@gmail.com

#+DESCRIPTION: zsh 配置文件
#+PROPERTY:    header-args        :mkdirp yes
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

*** zshenv 环境变量配置
    #+NAME: zshenv
    #+BEGIN_SRC shell :tangle (m/resolve "${m/home.d}/.zshenv") :eval never :exports code :comments link
      export LANG=en_US.UTF-8
      export JAVA_HOME="/Library/Java/JavaVirtualMachines/openjdk-13.0.1.jdk/Contents/Home"
      export EDITOR=vim
      export DISABLE_AUTO_TITLE=true
      export NOTMUCH_PROFILE=neo
      export XDG_CONFIG_HOME=${HOME}/.config
      export XDG_CACHE_HOME=${HOME}/.cache
      export XDG_DATA_HOME=${HOME}/.local/share
      export HOMEBREW_BUNDLE_FILE=${XDG_CONFIG_HOME}/homebrew-bundle/Brewfile
      export RIPGREP_CONFIG_PATH=${XDG_CONFIG_HOME}/ripgrep/config
      export VIMINIT='let $MYVIMRC="$XDG_CONFIG_HOME/vim/vimrc" | source $MYVIMRC'
      export VIMDOTDIR="$XDG_CONFIG_HOME/vim"

      export LESSHISTFILE="${XDG_DATA_HOME}/less/history"
      export LESSKEY="${XDG_CONFIG_HOME}/less/keys"

      export GEM_SPEC_CACHE=${XDG_CACHE_HOME}/rubygems/cache

      export INPUTRC=${XDG_CONFIG_HOME}/readline/inputrc
      #export GNUPGHOME=${XDG_CONFIG_HOME}/gnupg

      export ZDOTDIR="${XDG_CONFIG_HOME}/zsh"
    #+END_SRC

*** zsh xdg 配置
    #+BEGIN_SRC shell :eval yes :shebang #!/bin/bash :exports none :tangle no :results output silent :noweb yes :prologue "exec 2>&1" :epilogue ":" :comments link
      mkdir -p ${XDG_DATA_HOME}/{zsh,less,git}
    #+END_SRC
*** zshrc 配置
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/.zshrc") :eval never :exports code :comments link
      export ZPLUG_HOME=${XDG_CONFIG_HOME}/zsh/zplug
      export ZPLUG_REPOS=${XDG_CONFIG_HOME}/zplug/repos
      export ZPLUG_CACHE_DIR=${XDG_CACHE_HOME}/zplug
      export HISTFILE=${XDG_DATA_HOME}/zsh/history


      [[ $TERM == "tramp" ]] && unsetopt zle && PS1='$ '&& return
      for file in $(find ${XDG_CONFIG_HOME}/zsh/init -name "*.zsh"|sort); do
          source "${file}"
      done

      export ZPLUG_LOADFILE="${XDG_CONFIG_HOME}/zsh/zplugs.zsh"
      source ${ZPLUG_HOME}/init.zsh
      zplug install
      zplug load

      for file in ${XDG_CONFIG_HOME}/zsh/post/*.zsh; do
          source "${file}"
      done
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/init/python.zsh") :eval never :exports code :comments link
      export PATH="/usr/local/opt/python/libexec/bin:$PATH"
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/init/ruby.zsh") :eval never :exports code :comments link
      export PATH="/usr/local/opt/ruby/bin:$PATH"
    #+END_SRCS

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/init/brew.zsh") :eval never :exports code :comments link
      if [ -d "/usr/local/Cellar" ]; then
	  eval $(/usr/local/bin/brew shellenv);
      fi
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/init/init.zsh") :eval never :exports code :comments link
      if [ ! "$PATH_LOADED" = "true" ]; then
	  # Add go binaries
	  if [ -d "$GOPATH" ]; then
	      export PATH="$GOPATH/bin:$PATH"
	  elif [ $commands[go] ]; then
	      export PATH="$(go env GOPATH)/bin:$PATH"
	      export GOPATH="$(go env GOPATH)"
	  fi

	  if [ $commands[javac] ]; then
	      export JAVA_HOME="$(dirname $(dirname $(realpath $(which javac))))"
	  fi

	  # Add yarn global binaries
	  if [ $commands[yarn] ]; then export PATH="$(yarn global bin):$PATH"; fi

	  # Add ruby gems
	  if [ $commands[ruby] ]; then export PATH="$(ruby -e 'puts Gem.user_dir')/bin:$PATH"; fi

	  export PATH_LOADED="true"
      fi
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/zplugs.zsh") :eval never :exports code :comments link
      #!/usr/bin/env zsh
      # this allows zplug to update itself on `zplug update`
      zplug 'zplug/zplug', hook-build:'zplug --self-manage'

      zplug 'robbyrussell/oh-my-zsh', as:plugin, use:"lib/*.zsh"
      plugins=(extract common-aliases docker docker-compose git tmux tmuxinator autojump fzf gitignore fancy-ctrl-z cp alias-finder direnv urltools)
      for plugin in $plugins; do
	  zplug "plugins/$plugin", from:oh-my-zsh, as:plugin
      done

      zplug 'themes/robbyrussell', from:oh-my-zsh, use:robbyrussel.zsh-theme, as:theme

      zplug 'junegunn/fzf', use:"shell/*.zsh",  defer:2

      #### ZSH MAGIC
      zplug 'zsh-users/zsh-autosuggestions'
      zplug 'zsh-users/zsh-completions'
      zplug 'zsh-users/zsh-syntax-highlighting', defer:2
      zplug 'zsh-users/zsh-history-substring-search', defer:3
      return 0 # in case zplug adds plugs ignore them
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/loads.zsh") :eval never :exports code :comments link
      if [ -d "$HOME/.local" ]; then
	  export PATH="$HOME/.local/bin:$PATH";
      fi
    #+END_SRC

    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/config.zsh") :eval never :exports code :comments link
      # auto menu complete
      setopt auto_menu

      # auto change directory
      setopt auto_cd

      #### HISTORY SEARCH
      autoload history-search-end
      HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND="bg=cyan,fg=white,bold"
      HIST_STAMPS="dd.mm.yyyy" ## OH-MY-ZSH
      setopt hist_ignore_dups  # ignore duplication command history list
      setopt hist_ignore_space # ignore when commands starts with space
      setopt hist_reduce_blanks
      setopt hist_expire_dups_first
      setopt hist_find_no_dups

      # use brace
      setopt brace_ccl

      # auto directory pushd that you can get dirs list by cd -[tab]
      setopt auto_pushd
      setopt pushd_ignore_dups        # no duplicates in dir stack
      setopt pushd_silent             # no dir stack after pushd or popd
      setopt pushd_to_home            # `pushd` = `pushd $HOME`

      # compacked complete list display
      setopt list_packed

      # multi redirect (e.x. echo "hello" > hoge1.txt > hoge2.txt)
      setopt multios

      setopt auto_remove_slash        # self explicit
      setopt chase_links              # resolve symlinks
      setopt correct                  # try to correct spelling of commands
    #+END_SRC

*** tmux 连接到当前目录的实例上
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/functions.zsh") :eval never :exports code :comments link
      #!/bin/zsh
      # tat: tmux attach
      function tat {
	  name=$(basename `pwd` | sed -e 's/\.//g')

	  if tmux ls 2>&1 | grep "$name"; then
	      tmux attach -t "$name"
	  elif [ -f .envrc ]; then
	      direnv exec . tmux new-session -s "$name"
	  else
	      tmux new-session -s "$name"
	  fi
      }
    #+END_SRC

*** rg 命令管道相关处理，如果 rg 被输出到 terminal, 则使用 less 进行分页，否则直接输出所有结果
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/functions.zsh") :eval never :exports code :comments link
      function rg(){
	  # If outputting (fd 1 = stdout) directly to a terminal, page automatically:
	  if [ -t 1 ]; then
	      command rg --pretty "$@" \
		  | less --no-init --quit-if-one-screen --RAW-CONTROL-CHARS
	  else
	      command rg "$@"
	  fi
      }
    #+END_SRC

*** 获取当前用户的某个名字的进程
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/functions.zsh") :eval never :exports code :comments link
      function egrep(){
	  # If outputting (fd 1 = stdout) directly to a terminal, page automatically:
	  if [ -t 1 ]; then
	      command rg --pretty "$@" \
		  | less --no-init --quit-if-one-screen --RAW-CONTROL-CHARS
	  else
	      command rg "$@"
	  fi
      }
    #+END_SRC

*** 根据正则表达式生成随机值
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/functions.zsh") :eval never :exports code :comments link
      function regen(){
	  perl -e "use String::Random qw(random_regex random_string);print random_regex('$1');"
      }
    #+END_SRC

*** cmake 编译
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/alias.zsh") :eval never :exports code :comments link
      #!/bin/zsh
      mk() {
	  if [ -d build ]; then
	      cmake --build build --target ${1:-all} -j `nproc`
	  else
	      cmake --build cmake-build-debug --target ${1:-all} -j `nproc`
	  fi
      }

      mkt() {
	  if [ -d build ]; then
	      cmake --build build --target ${1:-test} -j `nproc`
	  else
	      cmake --build cmake-build-debug --target ${1:-test} -j `nproc`
	  fi
      }
      alias mux=tmuxinator
    #+END_SRC

*** xdg workaround
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/xdg.zsh") :eval never :exports code :comments link
      #!/bin/zsh
      alias tmux='tmux -f ${XDG_CONFIG_HOME}/tmux/tmux.conf'

      if [ -s "${XDG_CONFIG_HOME}/ssh/config" ]
      then
          SSH_CONFIG="-F ${XDG_CONFIG_HOME}/ssh/config"
      fi

      if [ -s "${XDG_CONFIG_HOME}/ssh/id_dsa" ]
      then
          SSH_ID="-i ${XDG_CONFIG_HOME}/ssh/id_dsa"
      fi

      alias ssh="ssh $SSH_CONFIG $SSH_ID "
      alias ssh-copy-id="ssh-copy-id $SSH_ID"

      alias mbsync="mbsync -c ${XDG_CONFIG_HOME}/isync/config"
    #+END_SRC

*** export http proxy
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/alias.zsh") :eval never :exports code :comments link
      pe() {
	  export http_proxy=http://127.0.0.1:8080 https_proxy=http://127.0.0.1:8080
      }
    #+END_SRC

*** 同步 emacs repo
    #+NAME: emacs_offline_home
    #+BEGIN_SRC shell :var offline_home=(m/resolve "${m/xdg.conf.d}/emacs/offline")
      realpath ${offline_home}
    #+END_SRC
    
    #+BEGIN_SRC shell :tangle (m/resolve "${m/xdg.conf.d}/zsh/post/functions.zsh") :eval never :exports code :comments link :noweb yes
      function rsync_emacs() {
          rsync --progress -ravz rsync://mirrors.tuna.tsinghua.edu.cn/elpa/ <<emacs_offline_home()>>
      }
    #+END_SRC

